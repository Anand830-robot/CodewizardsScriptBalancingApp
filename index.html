<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Speaker Percentage Calculator</title>
  <style>
    :root{--bg:#0b1020;--card:#121a33;--muted:#98a2b3;--text:#e6e8ef;--line:#243053;--accent:#7c9cff;--good:#2dd4bf;--warn:#fbbf24;--bad:#fb7185;}
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#070a14 0%, #0b1020 40%, #070a14 100%);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    a{color:var(--accent)}
    .wrap{max-width:1100px;margin:0 auto;padding:22px;}
    h1{margin:0 0 6px;font-size:26px;letter-spacing:.2px}
    .sub{color:var(--muted);margin:0 0 18px}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    @media (max-width: 900px){.grid{grid-template-columns:1fr}}
    .card{background:rgba(18,26,51,.92);border:1px solid rgba(36,48,83,.9);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:14px}
    .card h2{margin:0 0 10px;font-size:16px;color:#d7dcff}
    textarea{width:100%;min-height:210px;resize:vertical;background:#0b1020;color:var(--text);border:1px solid var(--line);border-radius:12px;padding:12px;font:13px/1.4 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;outline:none}
    textarea:focus,input:focus{border-color:rgba(124,156,255,.9);box-shadow:0 0 0 3px rgba(124,156,255,.18)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{appearance:none;border:1px solid var(--line);background:#0b1020;color:var(--text);padding:9px 12px;border-radius:12px;cursor:pointer}
    .btn:hover{border-color:rgba(124,156,255,.7)}
    .btn.primary{background:rgba(124,156,255,.18);border-color:rgba(124,156,255,.45)}
    .btn.danger{background:rgba(251,113,133,.12);border-color:rgba(251,113,133,.35)}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 10px;border:1px solid var(--line);border-radius:999px;background:#0b1020;color:var(--muted)}
    .pill b{color:var(--text)}
    .mini{font-size:12px;color:var(--muted)}
    table{width:100%;border-collapse:collapse;overflow:hidden;border-radius:12px}
    th,td{padding:10px 10px;border-bottom:1px solid rgba(36,48,83,.7);text-align:left}
    th{font-size:12px;color:var(--muted);font-weight:600}
    tr:hover td{background:rgba(124,156,255,.06)}
    .right{text-align:right}
    .nameCell{font-weight:600}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .controls .left{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input[type="text"],input[type="number"]{background:#0b1020;color:var(--text);border:1px solid var(--line);border-radius:12px;padding:9px 10px;outline:none}
    input[type="number"]{width:110px}
    .split{display:grid;grid-template-columns:1fr;gap:12px}
    canvas{width:100%;height:auto;background:#0b1020;border:1px solid var(--line);border-radius:12px}
    .legend{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    .key{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:12px}
    .swatch{width:12px;height:12px;border-radius:3px;border:1px solid rgba(255,255,255,.12)}
    .footer{margin-top:12px;color:var(--muted);font-size:12px}
    code{background:rgba(255,255,255,.06);padding:2px 6px;border-radius:8px}
    ul{margin:10px 0 0 18px}
    .tag{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(36,48,83,.9);background:rgba(124,156,255,.10);color:rgba(230,232,239,.95);font-size:11px;margin-right:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Speaker Percentage Calculator</h1>
    <p class="sub">Paste your script (format: <code>Name:</code> dialogue). The app counts words per speaker and calculates percentages (rounded to 0.1%).</p>

    <div class="grid">
      <div class="card">
        <h2>Paste script</h2>
        <textarea id="script" placeholder="Example:
Thomas: We are proud to present...
[High five]
Allison: Ugh, mapping this cave...
Aailya: Yeah, this is really hard work."></textarea>

        <div class="row" style="margin-top:10px">
          <button class="btn primary" id="analyzeBtn" type="button">Analyze script</button>
          <button class="btn" id="clearBtn" type="button">Clear</button>
          <span class="pill"><span>Total words:</span> <b id="totalWords">0</b></span>
          <span class="pill"><span>Speakers:</span> <b id="speakerCount">0</b></span>
          <span class="pill"><span>Ignored lines:</span> <b id="ignoredCount">0</b></span>
        </div>

        <div class="footer">
          Notes: lines starting with <code>[</code> or <code>(</code> are ignored as stage directions. Lines that start with <code>Slide</code> are ignored.
          If someone speaks across multiple lines, lines <em>without</em> <code>Name:</code> are treated as continuation of the previous speaker.
        </div>
      </div>

      <div class="card">
        <h2>Options</h2>
        <div class="split">
          <label class="mini"><input type="checkbox" id="ignoreBrackets" checked /> Ignore bracket/parenthesis stage directions</label>
          <label class="mini"><input type="checkbox" id="mergeSame" checked /> Merge repeated speaker blocks</label>
          <label class="mini"><input type="checkbox" id="caseSensitive" /> Case-sensitive names (normally OFF)</label>

          <div class="controls">
            <div class="left">
              <span class="mini">Sort:</span>
              <button class="btn" id="sortName" type="button">Name</button>
              <button class="btn" id="sortWords" type="button">Words</button>
              <button class="btn" id="sortPct" type="button">Percent</button>
            </div>
            <div class="left">
              <span class="mini">Direction:</span>
              <button class="btn" id="dirBtn" type="button">Desc</button>
            </div>
          </div>

          <div class="row">
            <button class="btn" id="downloadCsv" type="button">Download CSV</button>
            <button class="btn" id="copyCsv" type="button">Copy CSV</button>
            <button class="btn danger" id="resetData" type="button">Reset table</button>
          </div>

          <div class="mini">CSV columns: Speaker, Words, Percent</div>
        </div>
      </div>
    </div>

    <div class="grid" style="margin-top:16px">
      <div class="card">
        <h2>Results table</h2>

        <!-- Suggestions box -->
        <div id="suggestionsBox" style="margin:10px 0 12px; padding:12px; border:1px solid rgba(36,48,83,.7); border-radius:12px; background:#0b1020;">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
            <div style="font-weight:700; color:#d7dcff;">Suggestions</div>
            <label class="mini" style="display:flex; align-items:center; gap:8px; margin:0;">
              <input type="checkbox" id="enableSuggestions" checked />
              Enable
            </label>
          </div>
          <div class="mini" style="margin-top:6px; color:rgba(255,255,255,.65);">
            Script improvements: balance, clarity, flow, and “sounds better” tips.
          </div>
          <ul id="suggestionsList" style="margin:10px 0 0 18px; padding:0; color:rgba(230,232,239,.92);"></ul>
        </div>

        <div style="overflow:auto;border-radius:12px;border:1px solid rgba(36,48,83,.7)">
          <table id="tbl">
            <thead>
              <tr>
                <th>Speaker</th>
                <th class="right">Words</th>
                <th class="right">Percent</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div class="mini" style="margin-top:8px">Tip: If a name is misspelled in your script (e.g., Aaliya vs Aailya), it will count as two separate speakers.</div>
      </div>

      <div class="card">
        <h2>Visuals</h2>
        <div class="split">
          <div>
            <div class="mini" style="margin:0 0 6px">Pie chart (share)</div>
            <canvas id="pie" width="520" height="320"></canvas>
          </div>
          <div>
            <div class="mini" style="margin:0 0 6px">Bar chart (words)</div>
            <canvas id="bar" width="520" height="320"></canvas>
          </div>
          <div>
            <div class="mini" style="margin:0 0 6px">100% stacked bar (percent)</div>
            <canvas id="stack" width="520" height="120"></canvas>
          </div>
          <div class="legend" id="legend"></div>
        </div>
      </div>
    </div>

    <div class="footer" style="margin-top:18px">
      If your GitHub Pages page shows raw code: make sure this file is named <code>index.html</code> in your repository root (or in the configured Pages folder).
    </div>
  </div>

  <script>
    // ---------- Helpers ----------
    const $ = (id) => document.getElementById(id);

    function normalizeName(name, caseSensitive) {
      const n = (name || "").trim();
      if (!n) return "";
      if (caseSensitive) return n;
      return n[0].toUpperCase() + n.slice(1);
    }

    function countWords(text) {
      const m = (text || "").match(/[A-Za-z0-9]+(?:'[A-Za-z0-9]+)*/g);
      return m ? m.length : 0;
    }

    function splitSentences(text) {
      // Simple sentence split (good enough for suggestions)
      const t = (text || "").replace(/\s+/g, ' ').trim();
      if (!t) return [];
      return t.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(Boolean);
    }

    function hashColor(str) {
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      const hue = Math.abs(h) % 360;
      return `hsl(${hue} 70% 60%)`;
    }

    function round1(x) { return Math.round(x * 10) / 10; }

    function clipWords(text, n=12) {
      const words = (text || "").trim().split(/\s+/).filter(Boolean);
      if (words.length <= n) return words.join(' ');
      return words.slice(0, n).join(' ') + '…';
    }

    // ---------- Feature: merge tiny speakers into "Other" (< 1%) ----------
    function mergeTinyToOther(rows, totalWords, thresholdPct = 1.0) {
      if (!rows || rows.length === 0 || totalWords <= 0) return rows;

      const kept = [];
      let otherWords = 0;

      for (const r of rows) {
        const pct = (r.words / totalWords) * 100;
        if (pct < thresholdPct) otherWords += r.words;
        else kept.push({ ...r });
      }

      if (otherWords > 0) kept.push({ name: 'Other', words: otherWords, pct: 0 });

      const updatedTotal = kept.reduce((a, r) => a + r.words, 0);
      const withPct = kept.map(r => ({
        ...r,
        pct: updatedTotal > 0 ? round1((r.words / updatedTotal) * 100) : 0
      }));

      if (updatedTotal > 0) {
        const sum = withPct.reduce((a, r) => a + r.pct, 0);
        const drift = round1(100 - sum);
        if (Math.abs(drift) >= 0.1) {
          let idx = 0;
          for (let i = 1; i < withPct.length; i++) if (withPct[i].words > withPct[idx].words) idx = i;
          withPct[idx].pct = round1(withPct[idx].pct + drift);
        }
      }

      return withPct;
    }

    // ---------- Parsing ----------
    function parseScript(text, opts) {
      const lines = (text || "").split(/\r?\n/);
      const blocks = []; // {name, text, lineNo}
      let current = null;
      let ignored = 0;

      const nameLineRe = /^\s*([A-Z][A-Za-z0-9_\- ]{0,40}?)\s*:\s*(.*)\s*$/;
      const slideLineRe = /^\s*slide\b/i;

      for (let idx = 0; idx < lines.length; idx++) {
        const raw = lines[idx];
        const line = raw.trimEnd();
        const trimmed = line.trim();
        if (trimmed.length === 0) continue;

        if (slideLineRe.test(trimmed)) { ignored++; continue; }

        if (opts.ignoreBrackets) {
          if (trimmed.startsWith('[') || trimmed.startsWith('(')) { ignored++; continue; }
        }

        const m = line.match(nameLineRe);
        if (m) {
          const nmRaw = m[1] || "";
          const nm = normalizeName(nmRaw, opts.caseSensitive);
          if (/\bslide\b/i.test(nm)) { ignored++; current = null; continue; }

          const txt = (m[2] || "").trim();
          current = { name: nm, text: txt, lineNo: idx + 1 };
          blocks.push(current);
        } else {
          if (current) {
            if (slideLineRe.test(trimmed)) { ignored++; continue; }
            current.text = (current.text ? current.text + " " : "") + trimmed;
          } else {
            ignored++;
          }
        }
      }

      // Aggregate word counts
      const bySpeaker = new Map();
      for (const b of blocks) {
        const w = countWords(b.text);
        bySpeaker.set(b.name, (bySpeaker.get(b.name) || 0) + w);
      }

      let rows = [...bySpeaker.entries()]
        .map(([name, words]) => ({ name, words }))
        .filter(r => r.name.length > 0 && Number.isFinite(r.words));

      const total = rows.reduce((acc, r) => acc + r.words, 0);

      rows = rows.map(r => ({
        ...r,
        pct: total > 0 ? round1((r.words / total) * 100) : 0
      }));

      if (total > 0) {
        const sum = rows.reduce((a, r) => a + r.pct, 0);
        const drift = round1(100 - sum);
        if (Math.abs(drift) >= 0.1) {
          let idx = 0;
          for (let i = 1; i < rows.length; i++) if (rows[i].words > rows[idx].words) idx = i;
          rows[idx].pct = round1(rows[idx].pct + drift);
        }
      }

      // Merge tiny speakers
      rows = mergeTinyToOther(rows, total, 1.0);

      return { rows, totalWords: total, ignoredCount: ignored, blocks };
    }

    // ---------- Suggestions: "sounds better" engine ----------
    function levenshtein(a, b) {
      a = (a || "").toLowerCase();
      b = (b || "").toLowerCase();
      if (a === b) return 0;
      const m = a.length, n = b.length;
      const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
        }
      }
      return dp[m][n];
    }

    function addSuggestion(listEl, tag, text) {
      const li = document.createElement('li');
      const t = document.createElement('span');
      t.className = 'tag';
      t.textContent = tag;
      li.appendChild(t);
      li.appendChild(document.createTextNode(text));
      listEl.appendChild(li);
    }

    function renderSuggestions(rows, totalWords, blocks) {
      const list = $('suggestionsList');
      const enabledEl = $('enableSuggestions');
      list.innerHTML = '';

      const enabled = enabledEl ? enabledEl.checked : true;
      if (!enabled) { addSuggestion(list, 'Off', 'Suggestions are turned off.'); return; }

      if (!rows || rows.length === 0 || totalWords <= 0) {
        addSuggestion(list, 'Start', 'Paste a script and click Analyze to get suggestions.');
        return;
      }

      // 1) Balance (still helpful)
      const nonOtherRows = rows.filter(r => r.name !== 'Other');
      const sorted = [...rows].sort((a,b)=>b.pct-a.pct);
      const top = sorted[0];
      if (top && top.pct >= 35 && top.name !== 'Other') {
        const movePct = Math.max(0, top.pct - 30);
        const moveWords = Math.max(10, Math.round((movePct/100)*totalWords));
        addSuggestion(list, 'Balance', `${top.name} is speaking a lot (${top.pct.toFixed(1)}%). Consider moving about ${moveWords} words to other speakers for a smoother team feel.`);
      }

      // 2) Tiny speakers (excluding Other)
      const low = nonOtherRows.filter(r => r.pct > 0 && r.pct < 5);
      if (low.length > 0) {
        const names = low.map(r => `${r.name} (${r.pct.toFixed(1)}%)`).join(', ');
        addSuggestion(list, 'Balance', `Some speakers are very low: ${names}. Give each ~1–3 extra sentences so they feel intentional, not “cameo.”`);
      }

      // 3) Name mismatch detection
      const names = nonOtherRows.map(r => r.name);
      const pairs = [];
      for (let i = 0; i < names.length; i++) {
        for (let j = i + 1; j < names.length; j++) {
          const d = levenshtein(names[i], names[j]);
          const maxLen = Math.max(names[i].length, names[j].length);
          if (maxLen >= 4 && d > 0 && d <= 2) pairs.push([names[i], names[j]]);
        }
      }
      if (pairs.length > 0) {
        addSuggestion(list, 'Cleanup', `Possible name mismatches: ${pairs.slice(0,3).map(p=>`${p[0]} vs ${p[1]}`).join('; ')}. Make spelling consistent so counts + delivery are clean.`);
      }

      // Style / “sounds better” suggestions use blocks
      const allText = (blocks || []).map(b => b.text).join(' ').replace(/\s+/g,' ').trim();

      // 4) Long sentences: find top 3 longest sentences in entire script
      const sentences = splitSentences(allText);
      if (sentences.length > 0) {
        const scored = sentences.map(s => ({ s, w: countWords(s) })).sort((a,b)=>b.w-a.w);
        const longOnes = scored.filter(x => x.w >= 28).slice(0, 3);
        if (longOnes.length > 0) {
          addSuggestion(list, 'Flow', `You have ${longOnes.length} very long sentence(s) (28+ words). Split them into two shorter sentences for a punchier delivery.`);
          longOnes.forEach((x, i) => {
            addSuggestion(list, 'Example', `Long sentence ${i+1} (${x.w} words): “${clipWords(x.s, 14)}” → try: break after a natural pause (comma/“and”).`);
          });
        }
      }

      // 5) Repeated openers / filler phrases at start of lines
      const openerCounts = new Map();
      const openerPhrases = [
        "yeah", "so", "okay", "great job", "sounds like", "that's amazing", "interesting", "to conclude", "thank you"
      ];
      const blockStarts = (blocks || [])
        .map(b => (b.text || "").trim())
        .filter(Boolean)
        .map(t => t.split(/\s+/).slice(0, 3).join(' ').toLowerCase());

      for (const start of blockStarts) {
        for (const p of openerPhrases) {
          if (start.startsWith(p)) openerCounts.set(p, (openerCounts.get(p) || 0) + 1);
        }
      }
      const repeatedOpeners = [...openerCounts.entries()].filter(([p,c])=>c >= 3).sort((a,b)=>b[1]-a[1]);
      if (repeatedOpeners.length > 0) {
        const topRep = repeatedOpeners[0];
        addSuggestion(list, 'Variety', `A lot of lines start with “${topRep[0]}” (${topRep[1]} times). Vary openers so the script sounds less repetitive (e.g., “Here’s the key point…”, “Next…”, “What we learned was…”).`);
      }

      // 6) Too many "we" sentences in a row (monotone cadence)
      const weStarts = sentences.filter(s => /^\s*we\b/i.test(s)).length;
      if (sentences.length >= 6 && weStarts / sentences.length > 0.45) {
        addSuggestion(list, 'Voice', `Many sentences start with “We…” (${weStarts}/${sentences.length}). Mix in other structures: questions, “This means…”, “The result was…”, “That’s why…”, or start with the mission/robot instead of the team.`);
      }

      // 7) Acronyms & jargon: suggest defining once
      const acronyms = [
        { key: "qc", pretty: "QC", expand: "Quality Control" },
        { key: "pid", pretty: "PID", expand: "Proportional–Integral–Derivative" },
        { key: "lidar", pretty: "LiDAR", expand: "light detection and ranging" },
        { key: "github", pretty: "GitHub", expand: "our code collaboration site" },
        { key: "xcode", pretty: "Xcode", expand: "Apple’s development tool" }
      ];
      const lowerAll = allText.toLowerCase();
      const used = acronyms.filter(a => lowerAll.includes(a.key));
      if (used.length > 0) {
        const missingDefs = used.filter(a => !new RegExp(`\\b${a.pretty}\\b\\s*\\(`,'i').test(allText)); // crude: looks for "QC ("
        if (missingDefs.length > 0) {
          addSuggestion(list, 'Clarity', `Define acronyms the first time you say them. Example: “${missingDefs[0].pretty} (${missingDefs[0].expand})” so judges never feel lost.`);
        }
      }

      // 8) Transition structure check: hook/problem/solution/impact/close
      const hasProblem = /problem|danger|risk|challenge|hard|difficult/i.test(allText);
      const hasSolution = /solution|we created|we built|our robot|our app/i.test(allText);
      const hasImpact = /impact|inspire|mentor|worldwide|anyone|accessible|download/i.test(allText);
      const hasClose = /to conclude|in conclusion|do you have any questions|thank you/i.test(allText);
      if (!hasProblem || !hasSolution || !hasImpact || !hasClose) {
        const missing = [
          !hasProblem ? "problem" : null,
          !hasSolution ? "solution" : null,
          !hasImpact ? "impact" : null,
          !hasClose ? "closing line" : null
        ].filter(Boolean).join(", ");
        addSuggestion(list, 'Structure', `Consider tightening your story arc. Missing or weak: ${missing}. A clean flow is: Hook → Problem → Solution → Evidence → Impact → Close.`);
      } else {
        addSuggestion(list, 'Structure', `Your story arc is solid (problem → solution → impact → close). To make it sound even better, add one strong “hook” sentence at the very start.`);
      }

      // 9) Quick “make it punchier” micro-suggestions based on punctuation
      const exclamations = (allText.match(/!/g) || []).length;
      if (exclamations >= 6) {
        addSuggestion(list, 'Tone', `You use a lot of exclamation points (${exclamations}). Keeping only the biggest moments makes the excitement feel more real.`);
      }

      // 10) Provide a ready-to-use “hook + close” template
      addSuggestion(
        list,
        'Template',
        `Hook idea: “What if you could map a dangerous cave without stepping inside?” Close idea: “We’d love your questions—and you can try driving the robot now.”`
      );

      // If somehow nothing got added (shouldn't happen)
      if (list.children.length === 0) {
        addSuggestion(list, 'OK', 'No major issues detected. Looks good!');
      }
    }

    // ---------- Rendering ----------
    let state = {
      rows: [],
      totalWords: 0,
      ignoredCount: 0,
      sortKey: 'words',
      sortDir: 'desc',
      blocks: []
    };

    function sortedRows() {
      const mult = state.sortDir === 'asc' ? 1 : -1;
      const rows = [...state.rows];
      rows.sort((a, b) => {
        if (state.sortKey === 'name') return a.name.localeCompare(b.name) * mult;
        if (state.sortKey === 'pct') return (a.pct - b.pct) * mult;
        return (a.words - b.words) * mult;
      });
      return rows;
    }

    function renderTable() {
      const body = $('tbl').querySelector('tbody');
      body.innerHTML = '';
      const rows = sortedRows();

      for (const r of rows) {
        const tr = document.createElement('tr');

        const tdName = document.createElement('td');
        tdName.className = 'nameCell';
        tdName.textContent = r.name;

        const tdW = document.createElement('td');
        tdW.className = 'right';
        tdW.textContent = String(r.words);

        const tdP = document.createElement('td');
        tdP.className = 'right';
        tdP.textContent = `${r.pct.toFixed(1)}%`;

        tr.appendChild(tdName);
        tr.appendChild(tdW);
        tr.appendChild(tdP);
        body.appendChild(tr);
      }

      $('totalWords').textContent = String(state.totalWords);
      $('speakerCount').textContent = String(state.rows.length);
      $('ignoredCount').textContent = String(state.ignoredCount);
    }

    function renderLegend(rows) {
      const el = $('legend');
      el.innerHTML = '';
      for (const r of rows) {
        const key = document.createElement('div');
        key.className = 'key';
        const sw = document.createElement('span');
        sw.className = 'swatch';
        sw.style.background = hashColor(r.name);
        key.appendChild(sw);
        const label = document.createElement('span');
        label.textContent = `${r.name} (${r.pct.toFixed(1)}%)`;
        key.appendChild(label);
        el.appendChild(key);
      }
    }

    function clearCanvas(ctx, canvas) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#0b1020';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawPie(rows) {
      const c = $('pie');
      const ctx = c.getContext('2d');
      clearCanvas(ctx, c);

      const cx = c.width * 0.36;
      const cy = c.height * 0.5;
      const r = Math.min(c.width, c.height) * 0.34;

      const total = rows.reduce((a, r) => a + r.words, 0);
      let start = -Math.PI / 2;

      if (total <= 0) {
        ctx.fillStyle = 'rgba(255,255,255,.15)';
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,.6)';
        ctx.font = '14px system-ui';
        ctx.fillText('Paste a script and click Analyze', cx - r, cy);
        return;
      }

      for (const row of rows) {
        const frac = row.words / total;
        const end = start + frac * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, start, end);
        ctx.closePath();
        ctx.fillStyle = hashColor(row.name);
        ctx.fill();
        start = end;
      }

      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath(); ctx.arc(cx, cy, r * 0.55, 0, Math.PI * 2); ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      ctx.fillStyle = 'rgba(230,232,239,.9)';
      ctx.font = '600 16px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Total', cx, cy - 6);
      ctx.font = '600 18px system-ui';
      ctx.fillText(String(total), cx, cy + 18);
      ctx.textAlign = 'left';
    }

    function drawBar(rows) {
      const c = $('bar');
      const ctx = c.getContext('2d');
      clearCanvas(ctx, c);

      const padL = 46, padR = 14, padT = 18, padB = 28;
      const w = c.width - padL - padR;
      const h = c.height - padT - padB;

      const top = rows.slice(0, 12);
      const max = Math.max(1, ...top.map(r => r.words));

      ctx.strokeStyle = 'rgba(255,255,255,.12)';
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, padT + h);
      ctx.lineTo(padL + w, padT + h);
      ctx.stroke();

      const barGap = 8;
      const barW = (w - barGap * (top.length - 1)) / Math.max(1, top.length);

      ctx.font = '12px system-ui';
      ctx.fillStyle = 'rgba(255,255,255,.65)';

      for (let i = 0; i < top.length; i++) {
        const r0 = top[i];
        const bh = (r0.words / max) * (h - 10);
        const x = padL + i * (barW + barGap);
        const y = padT + h - bh;

        ctx.fillStyle = hashColor(r0.name);
        ctx.fillRect(x, y, barW, bh);

        ctx.fillStyle = 'rgba(230,232,239,.9)';
        ctx.textAlign = 'center';
        ctx.fillText(String(r0.words), x + barW / 2, y - 4);

        const label = r0.name.length > 10 ? r0.name.slice(0, 9) + '…' : r0.name;
        ctx.fillStyle = 'rgba(255,255,255,.7)';
        ctx.fillText(label, x + barW / 2, padT + h + 16);
      }
      ctx.textAlign = 'left';

      if (rows.length > top.length) {
        ctx.fillStyle = 'rgba(255,255,255,.55)';
        ctx.font = '12px system-ui';
        ctx.fillText(`Showing top ${top.length} of ${rows.length}`, padL, 14);
      }
    }

    function drawStack(rows) {
      const c = $('stack');
      const ctx = c.getContext('2d');
      clearCanvas(ctx, c);

      const pad = 14;
      const x0 = pad;
      const y0 = pad;
      const w = c.width - pad * 2;
      const h = c.height - pad * 2;

      const total = rows.reduce((a, r) => a + r.words, 0);
      if (total <= 0) return;

      let x = x0;
      for (const r0 of rows) {
        const segW = w * (r0.words / total);
        ctx.fillStyle = hashColor(r0.name);
        ctx.fillRect(x, y0, segW, h);
        x += segW;
      }

      ctx.strokeStyle = 'rgba(255,255,255,.15)';
      ctx.strokeRect(x0, y0, w, h);

      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('0%', x0, c.height - 4);
      ctx.fillText('50%', x0 + w/2, c.height - 4);
      ctx.fillText('100%', x0 + w, c.height - 4);
      ctx.textAlign = 'left';
    }

    function renderAll() {
      const rows = sortedRows();
      renderTable();
      drawPie(rows);
      drawBar(rows);
      drawStack(rows);
      renderLegend(rows);
      renderSuggestions(state.rows, state.totalWords, state.blocks);
    }

    // ---------- CSV ----------
    function toCSV(rows) {
      const header = 'Speaker,Words,Percent';
      const lines = rows.map(r => {
        const safe = '"' + String(r.name).replace(/"/g, '""') + '"';
        return `${safe},${r.words},${r.pct.toFixed(1)}`;
      });
      return [header, ...lines].join('\n');
    }

    function download(filename, text) {
      const blob = new Blob([text], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // ---------- Events ----------
    function wireEvents() {
      $('analyzeBtn').addEventListener('click', () => {
        const opts = {
          ignoreBrackets: $('ignoreBrackets').checked,
          mergeSame: $('mergeSame').checked,
          caseSensitive: $('caseSensitive').checked
        };
        const out = parseScript($('script').value, opts);
        state.rows = out.rows;
        state.totalWords = out.totalWords;
        state.ignoredCount = out.ignoredCount;
        state.blocks = out.blocks || [];
        renderAll();
      });

      $('clearBtn').addEventListener('click', () => { $('script').value = ''; });

      $('resetData').addEventListener('click', () => {
        state = { rows: [], totalWords: 0, ignoredCount: 0, sortKey: 'words', sortDir: 'desc', blocks: [] };
        renderAll();
      });

      $('sortName').addEventListener('click', () => { state.sortKey = 'name'; renderAll(); });
      $('sortWords').addEventListener('click', () => { state.sortKey = 'words'; renderAll(); });
      $('sortPct').addEventListener('click', () => { state.sortKey = 'pct'; renderAll(); });

      $('dirBtn').addEventListener('click', () => {
        state.sortDir = state.sortDir === 'asc' ? 'desc' : 'asc';
        $('dirBtn').textContent = state.sortDir === 'asc' ? 'Asc' : 'Desc';
        renderAll();
      });

      $('downloadCsv').addEventListener('click', () => {
        download('speaker_percentages.csv', toCSV(sortedRows()));
      });

      $('copyCsv').addEventListener('click', async () => {
        const csv = toCSV(sortedRows());
        try {
          await navigator.clipboard.writeText(csv);
          $('copyCsv').textContent = 'Copied!';
          setTimeout(() => $('copyCsv').textContent = 'Copy CSV', 900);
        } catch {
          const ta = document.createElement('textarea');
          ta.value = csv;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          ta.remove();
          $('copyCsv').textContent = 'Copied!';
          setTimeout(() => $('copyCsv').textContent = 'Copy CSV', 900);
        }
      });

      $('enableSuggestions').addEventListener('change', () => {
        renderSuggestions(state.rows, state.totalWords, state.blocks);
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      wireEvents();
      renderAll();
    });
  </script>
</body>
</html>
