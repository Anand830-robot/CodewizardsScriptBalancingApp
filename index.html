<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Speaker Percentage Calculator</title>
  <style>
    :root{
      --bg:#0b1020;--card:#121a33;--muted:#98a2b3;--text:#e6e8ef;--line:#243053;
      --accent:#7c9cff;--good:#2dd4bf;--warn:#fbbf24;--bad:#fb7185;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:linear-gradient(180deg,#070a14 0%, #0b1020 40%, #070a14 100%);
      color:var(--text);
      font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    }
    a{color:var(--accent)}
    .wrap{max-width:1100px;margin:0 auto;padding:22px;}
    h1{margin:0 0 6px;font-size:26px;letter-spacing:.2px}
    .sub{color:var(--muted);margin:0 0 18px}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    @media (max-width: 900px){.grid{grid-template-columns:1fr}}
    .card{
      background:rgba(18,26,51,.92);
      border:1px solid rgba(36,48,83,.9);
      border-radius:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      padding:14px;
    }
    .card h2{margin:0 0 10px;font-size:16px;color:#d7dcff}
    textarea{
      width:100%;
      min-height:140px;     /* smaller viewer input */
      max-height:220px;
      resize:vertical;
      overflow:auto;
      background:#0b1020;
      color:var(--text);
      border:1px solid var(--line);
      border-radius:12px;
      padding:12px;
      font:13px/1.4 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      outline:none;
    }
    textarea:focus,input:focus{border-color:rgba(124,156,255,.9);box-shadow:0 0 0 3px rgba(124,156,255,.18)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{
      appearance:none;
      border:1px solid var(--line);
      background:#0b1020;
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      cursor:pointer;
      pointer-events:auto;
      user-select:none;
    }
    .btn:hover{border-color:rgba(124,156,255,.7)}
    .btn.primary{background:rgba(124,156,255,.18);border-color:rgba(124,156,255,.45)}
    .btn.danger{background:rgba(251,113,133,.12);border-color:rgba(251,113,133,.35)}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 10px;border:1px solid var(--line);border-radius:999px;background:#0b1020;color:var(--muted)}
    .pill b{color:var(--text)}
    .mini{font-size:12px;color:var(--muted)}
    table{width:100%;border-collapse:collapse;overflow:hidden;border-radius:12px}
    th,td{padding:10px 10px;border-bottom:1px solid rgba(36,48,83,.7);text-align:left}
    th{font-size:12px;color:var(--muted);font-weight:600}
    tr:hover td{background:rgba(124,156,255,.06)}
    .right{text-align:right}
    .nameCell{font-weight:600}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .controls .left{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input[type="number"]{
      background:#0b1020;color:var(--text);
      border:1px solid var(--line);
      border-radius:12px;
      padding:9px 10px;
      outline:none;
      width:120px;
    }
    .split{display:grid;grid-template-columns:1fr;gap:12px}
    canvas{width:100%;height:auto;background:#0b1020;border:1px solid var(--line);border-radius:12px}
    .legend{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    .key{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:12px}
    .swatch{width:12px;height:12px;border-radius:3px;border:1px solid rgba(255,255,255,.12)}
    .footer{margin-top:12px;color:var(--muted);font-size:12px}
    code{background:rgba(255,255,255,.06);padding:2px 6px;border-radius:8px}

    /* Script viewer */
    .viewerWrap{margin-top:10px}
    .viewerTitle{font-size:12px;color:var(--muted);margin:0 0 6px}
    .scriptViewer{
      height:160px;               /* small window */
      overflow:auto;
      background:#0b1020;
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
      font:12px/1.45 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      color:rgba(230,232,239,.92);
      white-space:pre-wrap;
      word-break:break-word;
    }

    /* Suggestions panel */
    .sugg{
      background:#0b1020;
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px;
    }
    .sugg ul{margin:0;padding-left:18px}
    .sugg li{margin:6px 0;color:rgba(230,232,239,.9)}
    .tag{display:inline-flex;align-items:center;gap:6px;font-size:12px;color:var(--muted)}
    .dot{width:8px;height:8px;border-radius:999px;background:rgba(124,156,255,.9);display:inline-block}
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Speaker Percentage Calculator</h1>
    <p class="sub">
      Paste your script (format: <code>Name:</code> dialogue). The app counts words per speaker and calculates percentages.
      Lines that start with <code>Slide</code> are ignored. Speakers below the threshold are grouped into <code>Other</code>.
    </p>

    <div class="grid">
      <div class="card">
        <h2>Paste script</h2>
        <textarea id="script" placeholder="Example:
Thomas: We are proud to present...
[High five]
Allison: Ugh, mapping this cave...
Aailya: Yeah, this is really hard work."></textarea>

        <div class="viewerWrap">
          <div class="viewerTitle">Script Viewer (scrolls with your input)</div>
          <pre id="scriptViewer" class="scriptViewer"></pre>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="btn primary" id="analyzeBtn" type="button">Analyze script</button>
          <button class="btn" id="clearBtn" type="button">Clear</button>
          <span class="pill"><span>Total words:</span> <b id="totalWords">0</b></span>
          <span class="pill"><span>Speakers:</span> <b id="speakerCount">0</b></span>
          <span class="pill"><span>Ignored lines:</span> <b id="ignoredCount">0</b></span>
        </div>

        <div class="footer">
          Notes: lines starting with <code>[</code> or <code>(</code> are ignored as stage directions (optional).
          Lines starting with <code>Slide</code> are ignored. Lines without <code>Name:</code> are treated as continuation of the previous speaker.
        </div>
      </div>

      <div class="card">
        <h2>Options</h2>
        <div class="split">
          <label class="mini"><input type="checkbox" id="ignoreBrackets" checked /> Ignore bracket/parenthesis stage directions</label>
          <label class="mini"><input type="checkbox" id="caseSensitive" /> Case-sensitive names (normally OFF)</label>

          <div class="row" style="align-items:center;justify-content:space-between">
            <span class="mini">Group speakers under (%):</span>
            <input type="number" id="otherThreshold" min="0" max="50" step="0.1" value="1.0" />
          </div>

          <div class="controls">
            <div class="left">
              <span class="mini">Sort:</span>
              <button class="btn" id="sortName" type="button">Name</button>
              <button class="btn" id="sortWords" type="button">Words</button>
              <button class="btn" id="sortPct" type="button">Percent</button>
            </div>
            <div class="left">
              <span class="mini">Direction:</span>
              <button class="btn" id="dirBtn" type="button">Desc</button>
            </div>
          </div>

          <div class="row">
            <button class="btn" id="downloadCsv" type="button">Download CSV</button>
            <button class="btn" id="copyCsv" type="button">Copy CSV</button>
            <button class="btn danger" id="resetData" type="button">Reset</button>
          </div>

          <div class="mini">CSV columns: Speaker, Words, Percent</div>

          <div class="sugg">
            <div class="tag"><span class="dot"></span><b style="color:var(--text)">Script improvement suggestions</b></div>
            <div class="mini" style="margin:6px 0 8px">These are based on your actual text (no templates).</div>
            <ul id="suggestionsList">
              <li>Paste a script and click <b>Analyze</b>.</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="grid" style="margin-top:16px">
      <div class="card">
        <h2>Results table</h2>
        <div style="overflow:auto;border-radius:12px;border:1px solid rgba(36,48,83,.7)">
          <table id="tbl">
            <thead>
              <tr>
                <th>Speaker</th>
                <th class="right">Words</th>
                <th class="right">Percent</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div class="mini" style="margin-top:8px">
          Tip: If a name is misspelled in your script (e.g., Aaliya vs Aailya), it will count as two separate speakers.
        </div>
      </div>

      <div class="card">
        <h2>Visuals</h2>
        <div class="split">
          <div>
            <div class="mini" style="margin:0 0 6px">Pie chart (share)</div>
            <canvas id="pie" width="520" height="320"></canvas>
          </div>
          <div>
            <div class="mini" style="margin:0 0 6px">Bar chart (words)</div>
            <canvas id="bar" width="520" height="320"></canvas>
          </div>
          <div>
            <div class="mini" style="margin:0 0 6px">100% stacked bar (percent)</div>
            <canvas id="stack" width="520" height="120"></canvas>
          </div>
          <div class="legend" id="legend"></div>
        </div>
      </div>
    </div>

    <div class="footer" style="margin-top:18px">
      GitHub Pages tip: this file must be named <code>index.html</code> in the Pages folder you configured.
    </div>
  </div>

  <script>
    // Wrap everything so buttons always work (even if this script loads before the DOM is ready)
    window.addEventListener('DOMContentLoaded', () => {
      // ---------- Helpers ----------
      const $ = (id) => document.getElementById(id);

      function normalizeName(name, caseSensitive) {
        const n = (name || "").trim();
        if (!n) return "";
        if (caseSensitive) return n;
        // normalize: Title-case first letter, keep rest as-is
        return n[0].toUpperCase() + n.slice(1);
      }

      function countWords(text) {
        const m = (text || "").match(/[A-Za-z0-9]+(?:'[A-Za-z0-9]+)*/g);
        return m ? m.length : 0;
      }

      function hashColor(str) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        const hue = Math.abs(h) % 360;
        return `hsl(${hue} 70% 60%)`;
      }

      function round1(x) {
        return Math.round(x * 10) / 10;
      }

      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

      // ---------- Script Viewer (smaller window + synced scroll) ----------
      function updateViewerText() {
        const viewer = $('scriptViewer');
        if (!viewer) return;
        viewer.textContent = $('script').value || '';
      }

      function syncViewerScroll() {
        const ta = $('script');
        const viewer = $('scriptViewer');
        if (!ta || !viewer) return;

        const taScrollable = ta.scrollHeight - ta.clientHeight;
        const taPct = taScrollable > 0 ? (ta.scrollTop / taScrollable) : 0;

        const vScrollable = viewer.scrollHeight - viewer.clientHeight;
        viewer.scrollTop = taPct * Math.max(0, vScrollable);
      }

      $('script').addEventListener('input', () => {
        updateViewerText();
        syncViewerScroll();
      });

      $('script').addEventListener('scroll', () => {
        syncViewerScroll();
      });

      // ---------- Parsing ----------
      function parseScript(text, opts) {
        const lines = (text || "").split(/\r?\n/);
        const blocks = []; // {name, text}
        let current = null;
        let ignored = 0;

        // Name must start with a capital letter and end with a colon.
        const nameLineRe = /^\s*([A-Z][A-Za-z0-9_\- ]{0,40}?)\s*:\s*(.*)\s*$/;

        // Ignore any line that starts with "Slide" (case-insensitive)
        const slideLineRe = /^\s*slide\b/i;

        for (const raw of lines) {
          const line = raw.trimEnd();
          const trimmed = line.trim();
          if (trimmed.length === 0) continue;

          // Ignore slide headings like "Slide 8:" or "Slide 10 - ..."
          if (slideLineRe.test(trimmed)) { ignored++; continue; }

          // Ignore stage directions like [High five] or (points to...)
          if (opts.ignoreBrackets) {
            if (trimmed.startsWith('[') || trimmed.startsWith('(')) { ignored++; continue; }
          }

          const m = line.match(nameLineRe);
          if (m) {
            const nmRaw = m[1] || "";
            const nm = normalizeName(nmRaw, opts.caseSensitive);

            // Safety: if a "speaker name" contains the word "slide", ignore it
            if (/\bslide\b/i.test(nm)) { ignored++; current = null; continue; }

            const txt = (m[2] || "").trim();
            current = { name: nm, text: txt };
            blocks.push(current);
          } else {
            // Continuation line: attribute to the last speaker if any; otherwise ignore
            if (current) {
              if (slideLineRe.test(trimmed)) { ignored++; continue; }
              current.text = (current.text ? current.text + " " : "") + trimmed;
            } else {
              ignored++;
            }
          }
        }

        // Aggregate speaker word counts
        const bySpeaker = new Map();
        for (const b of blocks) {
          const w = countWords(b.text);
          bySpeaker.set(b.name, (bySpeaker.get(b.name) || 0) + w);
        }

        let rows = [...bySpeaker.entries()]
          .map(([name, words]) => ({ name, words }))
          .filter(r => r.name.length > 0 && Number.isFinite(r.words) && r.words > 0);

        const total = rows.reduce((acc, r) => acc + r.words, 0);

        // Exact pct for grouping (not rounded yet)
        rows = rows.map(r => ({
          ...r,
          pctExact: total > 0 ? (r.words / total) * 100 : 0
        }));

        return { rows, totalWords: total, ignoredCount: ignored };
      }

      function mergeUnderThreshold(rows, thresholdPct) {
        const t = Math.max(0, Number(thresholdPct) || 0);
        if (!rows.length) return rows;

        const big = [];
        let otherWords = 0;

        for (const r of rows) {
          if (r.pctExact < t) otherWords += r.words;
          else big.push(r);
        }

        // If nothing fell under threshold, return unchanged
        if (otherWords <= 0) return big;

        // If everything fell under threshold, just return one "Other"
        if (big.length === 0) {
          return [{ name: 'Other', words: otherWords, pctExact: 100 }];
        }

        big.push({ name: 'Other', words: otherWords, pctExact: 0 }); // pctExact re-computed later
        return big;
      }

      function computeDisplayPct(rows) {
        const total = rows.reduce((a, r) => a + r.words, 0);
        const withPct = rows.map(r => ({
          name: r.name,
          words: r.words,
          pct: total > 0 ? round1((r.words / total) * 100) : 0
        }));

        // Fix rounding drift: adjust largest slice so sum=100.0
        if (total > 0 && withPct.length > 0) {
          const sum = withPct.reduce((a, r) => a + r.pct, 0);
          const drift = round1(100 - sum);
          if (Math.abs(drift) >= 0.1) {
            let idx = 0;
            for (let i = 1; i < withPct.length; i++) {
              if (withPct[i].words > withPct[idx].words) idx = i;
            }
            withPct[idx].pct = round1(withPct[idx].pct + drift);
          }
        }
        return { withPct, total };
      }

      // ---------- Rendering State ----------
      let state = {
        rows: [],
        totalWords: 0,
        ignoredCount: 0,
        sortKey: 'words',
        sortDir: 'desc'
      };

      function sortedRows() {
        const mult = state.sortDir === 'asc' ? 1 : -1;
        const rows = [...state.rows];
        rows.sort((a, b) => {
          if (state.sortKey === 'name') return a.name.localeCompare(b.name) * mult;
          if (state.sortKey === 'pct') return (a.pct - b.pct) * mult;
          return (a.words - b.words) * mult;
        });
        return rows;
      }

      function renderTable() {
        const body = $('tbl').querySelector('tbody');
        body.innerHTML = '';
        const rows = sortedRows();

        for (const r of rows) {
          const tr = document.createElement('tr');

          const tdName = document.createElement('td');
          tdName.className = 'nameCell';
          tdName.textContent = r.name;

          const tdW = document.createElement('td');
          tdW.className = 'right';
          tdW.textContent = String(r.words);

          const tdP = document.createElement('td');
          tdP.className = 'right';
          tdP.textContent = `${r.pct.toFixed(1)}%`;

          tr.appendChild(tdName);
          tr.appendChild(tdW);
          tr.appendChild(tdP);
          body.appendChild(tr);
        }

        $('totalWords').textContent = String(state.totalWords);
        $('speakerCount').textContent = String(state.rows.length);
        $('ignoredCount').textContent = String(state.ignoredCount);
      }

      function renderLegend(rows) {
        const el = $('legend');
        el.innerHTML = '';
        for (const r of rows) {
          const key = document.createElement('div');
          key.className = 'key';
          const sw = document.createElement('span');
          sw.className = 'swatch';
          sw.style.background = hashColor(r.name);
          key.appendChild(sw);
          const label = document.createElement('span');
          label.textContent = `${r.name} (${r.pct.toFixed(1)}%)`;
          key.appendChild(label);
          el.appendChild(key);
        }
      }

      function clearCanvas(ctx, canvas) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0b1020';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      function drawPie(rows) {
        const c = $('pie');
        const ctx = c.getContext('2d');
        clearCanvas(ctx, c);

        const cx = c.width * 0.36;
        const cy = c.height * 0.5;
        const r = Math.min(c.width, c.height) * 0.34;

        const total = rows.reduce((a, r) => a + r.words, 0);
        let start = -Math.PI / 2;

        if (total <= 0) {
          ctx.fillStyle = 'rgba(255,255,255,.15)';
          ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,.6)';
          ctx.font = '14px system-ui';
          ctx.fillText('Paste a script and click Analyze', cx - r, cy);
          return;
        }

        for (const row of rows) {
          const frac = row.words / total;
          const end = start + frac * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.arc(cx, cy, r, start, end);
          ctx.closePath();
          ctx.fillStyle = hashColor(row.name);
          ctx.fill();
          start = end;
        }

        // donut hole
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath(); ctx.arc(cx, cy, r * 0.55, 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';

        // center text
        ctx.fillStyle = 'rgba(230,232,239,.9)';
        ctx.font = '600 16px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Total', cx, cy - 6);
        ctx.font = '600 18px system-ui';
        ctx.fillText(String(total), cx, cy + 18);
        ctx.textAlign = 'left';
      }

      function drawBar(rows) {
        const c = $('bar');
        const ctx = c.getContext('2d');
        clearCanvas(ctx, c);

        const padL = 46, padR = 14, padT = 18, padB = 28;
        const w = c.width - padL - padR;
        const h = c.height - padT - padB;

        const top = rows.slice(0, 12);
        const max = Math.max(1, ...top.map(r => r.words));

        // axes
        ctx.strokeStyle = 'rgba(255,255,255,.12)';
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT + h);
        ctx.lineTo(padL + w, padT + h);
        ctx.stroke();

        const barGap = 8;
        const barW = (w - barGap * (top.length - 1)) / Math.max(1, top.length);

        ctx.font = '12px system-ui';
        ctx.fillStyle = 'rgba(255,255,255,.65)';

        for (let i = 0; i < top.length; i++) {
          const r0 = top[i];
          const bh = (r0.words / max) * (h - 10);
          const x = padL + i * (barW + barGap);
          const y = padT + h - bh;

          ctx.fillStyle = hashColor(r0.name);
          ctx.fillRect(x, y, barW, bh);

          ctx.fillStyle = 'rgba(230,232,239,.9)';
          ctx.textAlign = 'center';
          ctx.fillText(String(r0.words), x + barW / 2, y - 4);

          const label = r0.name.length > 10 ? r0.name.slice(0, 9) + '…' : r0.name;
          ctx.fillStyle = 'rgba(255,255,255,.7)';
          ctx.fillText(label, x + barW / 2, padT + h + 16);
        }
        ctx.textAlign = 'left';

        if (rows.length > top.length) {
          ctx.fillStyle = 'rgba(255,255,255,.55)';
          ctx.font = '12px system-ui';
          ctx.fillText(`Showing top ${top.length} of ${rows.length}`, padL, 14);
        }
      }

      function drawStack(rows) {
        const c = $('stack');
        const ctx = c.getContext('2d');
        clearCanvas(ctx, c);

        const pad = 14;
        const x0 = pad;
        const y0 = pad;
        const w = c.width - pad * 2;
        const h = c.height - pad * 2;

        const total = rows.reduce((a, r) => a + r.words, 0);
        if (total <= 0) return;

        let x = x0;
        for (const r0 of rows) {
          const segW = w * (r0.words / total);
          ctx.fillStyle = hashColor(r0.name);
          ctx.fillRect(x, y0, segW, h);
          x += segW;
        }

        ctx.strokeStyle = 'rgba(255,255,255,.15)';
        ctx.strokeRect(x0, y0, w, h);

        ctx.fillStyle = 'rgba(255,255,255,.65)';
        ctx.font = '12px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('0%', x0, c.height - 4);
        ctx.fillText('50%', x0 + w/2, c.height - 4);
        ctx.fillText('100%', x0 + w, c.height - 4);
        ctx.textAlign = 'left';
      }

      function renderAll() {
        const rows = sortedRows();
        renderTable();
        drawPie(rows);
        drawBar(rows);
        drawStack(rows);
        renderLegend(rows);
      }

      // ---------- Suggestions (NO template lines; only text-based signals) ----------
      function setSuggestions(items) {
        const ul = $('suggestionsList');
        ul.innerHTML = '';
        if (!items.length) {
          const li = document.createElement('li');
          li.textContent = 'No suggestions right now.';
          ul.appendChild(li);
          return;
        }
        for (const s of items) {
          const li = document.createElement('li');
          li.textContent = s;
          ul.appendChild(li);
        }
      }

      function generateSuggestions(rawText, parsedRows, totalWords, ignoredCount) {
        const suggestions = [];
        const text = (rawText || '').trim();
        if (!text) return ['Paste a script, then click Analyze.'];

        // Estimated speaking time (roughly 130–160 wpm)
        const wpm = 145;
        const minutes = totalWords / wpm;
        if (totalWords > 0) {
          if (minutes > 3.5) suggestions.push(`This is about ${minutes.toFixed(1)} minutes at a normal speaking pace. Consider trimming if you need it under ~3 minutes.`);
          else suggestions.push(`Estimated speaking time: ~${minutes.toFixed(1)} minutes at a normal pace.`);
        }

        // Balance: biggest speaker share
        if (parsedRows.length >= 2 && totalWords > 0) {
          const sorted = [...parsedRows].sort((a,b)=>b.words-a.words);
          const top = sorted[0];
          const topPct = (top.words / totalWords) * 100;
          if (topPct > 45) suggestions.push(`${top.name} speaks ~${topPct.toFixed(1)}% of the words. If you want it more balanced, move 1–2 sentences to other speakers.`);
          const bottom = sorted[sorted.length - 1];
          const bottomPct = (bottom.words / totalWords) * 100;
          if (bottomPct < 3) suggestions.push(`${bottom.name} has a very small part (~${bottomPct.toFixed(1)}%). Consider giving them 1 extra line so every speaker feels involved.`);
        }

        // Potential name inconsistencies (same letters different spacing/case)
        const names = parsedRows.map(r => r.name);
        const normalized = names.map(n => n.toLowerCase().replace(/\s+/g,''));
        const seen = new Map();
        for (let i=0;i<names.length;i++){
          const k = normalized[i];
          if (!seen.has(k)) seen.set(k, [names[i]]);
          else seen.get(k).push(names[i]);
        }
        for (const arr of seen.values()){
          const uniq = [...new Set(arr)];
          if (uniq.length >= 2) {
            suggestions.push(`Possible name inconsistency: ${uniq.join(' vs ')}. If these are the same person, pick one spelling so counts match.`);
          }
        }

        // Long lines (hard to speak)
        const lines = rawText.split(/\r?\n/);
        let longLineCount = 0;
        for (const ln of lines) {
          const t = ln.trim();
          if (!t) continue;
          if (/^\s*slide\b/i.test(t)) continue;
          if (t.startsWith('[') || t.startsWith('(')) continue;
          // ignore speaker name portion when measuring
          const afterColon = t.includes(':') ? t.split(':').slice(1).join(':').trim() : t;
          if (afterColon.length >= 160) longLineCount++;
        }
        if (longLineCount >= 2) suggestions.push(`You have ${longLineCount} very long lines. Consider splitting them into shorter sentences to sound more natural.`);
        else if (longLineCount === 1) suggestions.push(`There’s 1 very long line. Splitting it into 2 lines can make delivery easier.`);

        // Filler/repetition checks
        const lower = rawText.toLowerCase();
        const fillers = ['basically', 'um', 'uh', 'like,', 'you know', 'so,', 'so basically'];
        const fillerHits = fillers.filter(f => lower.includes(f));
        if (fillerHits.length) suggestions.push(`Check for filler phrases (${fillerHits.join(', ')}). Removing a few can make it sound sharper.`);

        // Stage directions count
        const bracketLines = lines.filter(l => l.trim().startsWith('[') || l.trim().startsWith('(')).length;
        if (bracketLines > 8) suggestions.push(`You have ${bracketLines} stage-direction lines. If time is tight, keep only the ones that add clarity or fun.`);

        // Ignored lines might indicate formatting issues
        if (ignoredCount > 10) suggestions.push(`Ignored lines: ${ignoredCount}. If that seems too high, check for missing "Name:" prefixes on dialogue lines.`);

        // Q/A ending
        if (!/do you have any questions/i.test(rawText) && totalWords > 0) {
          suggestions.push(`Consider ending with an invitation for questions (e.g., “Do you have any questions?”) so the transition to Q&A feels smooth.`);
        }

        return suggestions.slice(0, 10);
      }

      // ---------- CSV ----------
      function toCSV(rows) {
        const header = 'Speaker,Words,Percent';
        const lines = rows.map(r => {
          const safe = '"' + String(r.name).replace(/"/g, '""') + '"';
          return `${safe},${r.words},${r.pct.toFixed(1)}`;
        });
        return [header, ...lines].join('\n');
      }

      function download(filename, text) {
        const blob = new Blob([text], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      // ---------- Analyze ----------
      function analyzeNow() {
        const opts = {
          ignoreBrackets: $('ignoreBrackets').checked,
          caseSensitive: $('caseSensitive').checked
        };

        const threshold = clamp(Number($('otherThreshold').value || 0), 0, 50);

        const parsed = parseScript($('script').value, opts);

        // merge low-percentage speakers into Other BEFORE display
        let merged = mergeUnderThreshold(parsed.rows, threshold);

        // recompute display percentages and totals
        const { withPct, total } = computeDisplayPct(merged);

        state.rows = withPct;
        state.totalWords = total;
        state.ignoredCount = parsed.ignoredCount;

        // Suggestions based on raw + distribution (use original parsed rows for balance signals)
        const sugg = generateSuggestions($('script').value, parsed.rows, total, parsed.ignoredCount);
        setSuggestions(sugg);

        renderAll();
      }

      // ---------- Events ----------
      $('analyzeBtn').addEventListener('click', analyzeNow);

      $('clearBtn').addEventListener('click', () => {
        $('script').value = '';
        updateViewerText();
        syncViewerScroll();
        setSuggestions(['Paste a script and click Analyze.']);
      });

      $('resetData').addEventListener('click', () => {
        state = { rows: [], totalWords: 0, ignoredCount: 0, sortKey: 'words', sortDir: 'desc' };
        $('totalWords').textContent = '0';
        $('speakerCount').textContent = '0';
        $('ignoredCount').textContent = '0';
        setSuggestions(['Paste a script and click Analyze.']);
        renderAll();
      });

      $('sortName').addEventListener('click', () => { state.sortKey = 'name'; renderAll(); });
      $('sortWords').addEventListener('click', () => { state.sortKey = 'words'; renderAll(); });
      $('sortPct').addEventListener('click', () => { state.sortKey = 'pct'; renderAll(); });

      $('dirBtn').addEventListener('click', () => {
        state.sortDir = state.sortDir === 'asc' ? 'desc' : 'asc';
        $('dirBtn').textContent = state.sortDir === 'asc' ? 'Asc' : 'Desc';
        renderAll();
      });

      $('otherThreshold').addEventListener('change', () => {
        // if user already analyzed, re-run to regroup
        if (($('script').value || '').trim().length > 0) analyzeNow();
      });

      $('downloadCsv').addEventListener('click', () => {
        const rows = sortedRows();
        download('speaker_percentages.csv', toCSV(rows));
      });

      $('copyCsv').addEventListener('click', async () => {
        const rows = sortedRows();
        const csv = toCSV(rows);
        try {
          await navigator.clipboard.writeText(csv);
          $('copyCsv').textContent = 'Copied!';
          setTimeout(() => $('copyCsv').textContent = 'Copy CSV', 900);
        } catch {
          const ta = document.createElement('textarea');
          ta.value = csv;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          ta.remove();
          $('copyCsv').textContent = 'Copied!';
          setTimeout(() => $('copyCsv').textContent = 'Copy CSV', 900);
        }
      });

      // Initial paint
      updateViewerText();
      renderAll();
    });
  </script>
</body>
</html>
